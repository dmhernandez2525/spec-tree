/**
 * Tests for useCursorRulesImport hook
 *
 * F2.1.2 - Cursor Rules import
 */

import { renderHook, act } from '@testing-library/react';
import { describe, it, expect, vi } from 'vitest';
import {
  useCursorRulesImport,
  parseFrontmatter,
  extractTechStack,
  extractConventions,
  extractForbiddenPatterns,
  extractFileStructure,
  extractPatterns,
  formatTechStack,
  validateMDCContent,
} from './useCursorRulesImport';

const sampleMDCContent = `---
title: Project Rules
description: AI coding rules generated by Spec Tree
globs: ["src/**/*"]
alwaysApply: false
---

# Project: E-Commerce Platform

## Tech Stack
- **Framework**: Next.js 14 (App Router)
- **Language**: TypeScript (strict mode)
- **Styling**: Tailwind CSS
- **State**: Zustand + TanStack Query
- **Forms**: React Hook Form + Zod
- **UI**: Radix UI primitives

## Code Style
- Use \`cn()\` utility for conditional Tailwind classes
- Components in PascalCase: \`MyComponent.tsx\`
- Hooks with \`use\` prefix: \`useMyHook.ts\`
- Types with \`interface\` keyword (not \`type\` for objects)

## Forbidden Patterns
- NO \`any\` types
- NO \`@ts-ignore\`
- NO \`console.log\` (use logger service)
- NO empty catch blocks

## File Structure
\`\`\`
src/
├── app/              # Next.js App Router pages
├── components/       # React components
│   ├── ui/          # Reusable UI components
│   └── features/    # Feature-specific components
├── hooks/           # Custom React hooks
├── lib/             # Utilities and services
├── types/           # TypeScript type definitions
└── store/           # Zustand stores
\`\`\`

## Reference Patterns
- Button pattern: \`src/components/ui/button.tsx\`
- Form pattern: \`src/components/forms/LoginForm.tsx\`
- API pattern: \`src/lib/api/client.ts\`
`;

describe('parseFrontmatter', () => {
  it('should parse frontmatter with string values', () => {
    const content = `---
title: Test Rules
description: Test description
---

Body content here`;

    const { frontmatter, body } = parseFrontmatter(content);

    expect(frontmatter.title).toBe('Test Rules');
    expect(frontmatter.description).toBe('Test description');
    expect(body).toContain('Body content here');
  });

  it('should parse frontmatter with boolean values', () => {
    const content = `---
alwaysApply: true
enabled: false
---

Body`;

    const { frontmatter } = parseFrontmatter(content);

    expect(frontmatter.alwaysApply).toBe(true);
    expect(frontmatter.enabled).toBe(false);
  });

  it('should parse frontmatter with array values', () => {
    const content = `---
globs:
- "src/**/*"
- "lib/**/*.ts"
---

Body`;

    const { frontmatter } = parseFrontmatter(content);

    expect(frontmatter.globs).toEqual(['src/**/*', 'lib/**/*.ts']);
  });

  it('should parse inline array values', () => {
    const content = `---
globs: ["src/**/*", "lib/**/*.ts"]
---

Body`;

    const { frontmatter } = parseFrontmatter(content);

    expect(frontmatter.globs).toEqual(['src/**/*', 'lib/**/*.ts']);
  });

  it('should handle content without frontmatter', () => {
    const content = '# Just a title\n\nSome content';

    const { frontmatter, body } = parseFrontmatter(content);

    expect(frontmatter).toEqual({});
    expect(body).toBe(content);
  });
});

describe('extractTechStack', () => {
  it('should extract tech stack from content', () => {
    const techStack = extractTechStack(sampleMDCContent);

    expect(techStack.framework).toBe('Next.js 14 (App Router)');
    expect(techStack.language).toBe('TypeScript (strict mode)');
    expect(techStack.styling).toBe('Tailwind CSS');
    expect(techStack.stateManagement).toBe('Zustand + TanStack Query');
    expect(techStack.forms).toBe('React Hook Form + Zod');
    expect(techStack.ui).toBe('Radix UI primitives');
  });

  it('should return empty tech stack when section not found', () => {
    const content = '# No tech stack here';
    const techStack = extractTechStack(content);

    expect(techStack.items).toEqual([]);
    expect(techStack.framework).toBeUndefined();
  });

  it('should collect all items', () => {
    const techStack = extractTechStack(sampleMDCContent);

    expect(techStack.items.length).toBeGreaterThan(0);
    expect(techStack.items.some((i) => i.name === 'Framework')).toBe(true);
  });
});

describe('extractConventions', () => {
  it('should extract code style conventions', () => {
    const conventions = extractConventions(sampleMDCContent);

    expect(conventions.length).toBeGreaterThan(0);
    // Check that some convention mentions cn() either in rule or example
    expect(conventions.some((c) => c.rule.includes('cn()') || c.example === 'cn()')).toBe(true);
  });

  it('should return empty array when section not found', () => {
    const content = '# No conventions here';
    const conventions = extractConventions(content);

    expect(conventions).toEqual([]);
  });
});

describe('extractForbiddenPatterns', () => {
  it('should extract forbidden patterns', () => {
    const patterns = extractForbiddenPatterns(sampleMDCContent);

    // Should extract patterns from the Forbidden Patterns section
    expect(patterns.length).toBeGreaterThanOrEqual(1);
    // Check that patterns contain expected text (may or may not include backticks)
    const allPatternText = patterns.map((p) => p.pattern).join(' ');
    expect(
      allPatternText.includes('any') ||
      allPatternText.includes('@ts-ignore') ||
      allPatternText.includes('console.log') ||
      allPatternText.includes('catch')
    ).toBe(true);
  });

  it('should return empty array when section not found', () => {
    const content = '# No forbidden patterns here';
    const patterns = extractForbiddenPatterns(content);

    expect(patterns).toEqual([]);
  });
});

describe('extractFileStructure', () => {
  it('should extract file structure', () => {
    const structure = extractFileStructure(sampleMDCContent);

    expect(structure.length).toBeGreaterThan(0);
    expect(structure.some((s) => s.path.includes('app'))).toBe(true);
    expect(structure.some((s) => s.path.includes('components'))).toBe(true);
  });

  it('should include descriptions when present', () => {
    const structure = extractFileStructure(sampleMDCContent);
    const appEntry = structure.find((s) => s.path === 'app');

    expect(appEntry?.description).toBe('Next.js App Router pages');
  });

  it('should return empty array when section not found', () => {
    const content = '# No file structure here';
    const structure = extractFileStructure(content);

    expect(structure).toEqual([]);
  });
});

describe('extractPatterns', () => {
  it('should extract reference patterns', () => {
    const patterns = extractPatterns(sampleMDCContent);

    expect(patterns.length).toBeGreaterThan(0);
    expect(patterns.some((p) => p.path.includes('button.tsx'))).toBe(true);
  });

  it('should return empty array when section not found', () => {
    const content = '# No patterns here';
    const patterns = extractPatterns(content);

    expect(patterns).toEqual([]);
  });
});

describe('useCursorRulesImport', () => {
  describe('importFromContent', () => {
    it('should parse complete MDC content', () => {
      const { result } = renderHook(() => useCursorRulesImport());

      const parsed = result.current.importFromContent(sampleMDCContent);

      expect(parsed.frontmatter.title).toBe('Project Rules');
      expect(parsed.projectName).toBe('E-Commerce Platform');
      expect(parsed.techStack.framework).toBe('Next.js 14 (App Router)');
      expect(parsed.conventions.length).toBeGreaterThan(0);
      expect(parsed.forbiddenPatterns.length).toBeGreaterThanOrEqual(3);
      expect(parsed.fileStructure.length).toBeGreaterThan(0);
      expect(parsed.patterns.length).toBeGreaterThan(0);
    });

    it('should handle minimal content', () => {
      const { result } = renderHook(() => useCursorRulesImport());

      const parsed = result.current.importFromContent('# Simple content');

      expect(parsed.frontmatter).toEqual({});
      expect(parsed.techStack.items).toEqual([]);
      expect(parsed.conventions).toEqual([]);
    });
  });

  describe('importFromFiles', () => {
    it('should import multiple files', async () => {
      const { result } = renderHook(() => useCursorRulesImport());

      const file1 = new File([sampleMDCContent], 'project.mdc', { type: 'text/plain' });
      const file2 = new File(['# Another file\n## Tech Stack\n- **Database**: PostgreSQL'], 'backend.mdc', { type: 'text/plain' });

      let importResult;
      await act(async () => {
        importResult = await result.current.importFromFiles([file1, file2]);
      });

      expect(importResult!.rules.length).toBe(2);
      expect(importResult!.errors.length).toBe(0);
      expect(importResult!.projectContext.name).toBe('E-Commerce Platform');
      expect(importResult!.projectContext.techStack.database).toBe('PostgreSQL');
    });

    it('should handle file read errors gracefully', async () => {
      const { result } = renderHook(() => useCursorRulesImport());

      // Create a mock file that throws on text()
      const badFile = {
        name: 'bad.mdc',
        text: () => Promise.reject(new Error('Read error')),
      } as unknown as File;

      const goodFile = new File(['# Good content'], 'good.mdc', { type: 'text/plain' });

      let importResult;
      await act(async () => {
        importResult = await result.current.importFromFiles([badFile, goodFile]);
      });

      expect(importResult!.rules.length).toBe(1);
      expect(importResult!.errors.length).toBe(1);
      expect(importResult!.errors[0].file).toBe('bad.mdc');
    });

    it('should call onImportComplete callback', async () => {
      const onImportComplete = vi.fn();
      const { result } = renderHook(() =>
        useCursorRulesImport({ onImportComplete })
      );

      const file = new File([sampleMDCContent], 'test.mdc', { type: 'text/plain' });

      await act(async () => {
        await result.current.importFromFiles([file]);
      });

      expect(onImportComplete).toHaveBeenCalledTimes(1);
      expect(onImportComplete).toHaveBeenCalledWith(
        expect.objectContaining({
          rules: expect.any(Array),
          projectContext: expect.any(Object),
        })
      );
    });

    it('should track importing state', async () => {
      const { result } = renderHook(() => useCursorRulesImport());

      expect(result.current.isImporting).toBe(false);

      const file = new File([sampleMDCContent], 'test.mdc', { type: 'text/plain' });

      await act(async () => {
        const importPromise = result.current.importFromFiles([file]);
        // During import, isImporting should be true
        // (though this is hard to test synchronously)
        await importPromise;
      });

      expect(result.current.isImporting).toBe(false);
      expect(result.current.lastResult).not.toBeNull();
    });
  });

  describe('reset', () => {
    it('should reset state', async () => {
      const { result } = renderHook(() => useCursorRulesImport());

      const file = new File([sampleMDCContent], 'test.mdc', { type: 'text/plain' });

      await act(async () => {
        await result.current.importFromFiles([file]);
      });

      expect(result.current.lastResult).not.toBeNull();

      act(() => {
        result.current.reset();
      });

      expect(result.current.lastResult).toBeNull();
      expect(result.current.error).toBeNull();
    });
  });

  describe('aggregation', () => {
    it('should aggregate tech stack from multiple files', async () => {
      const { result } = renderHook(() => useCursorRulesImport());

      const file1Content = `---
title: Frontend Rules
---

## Tech Stack
- **Framework**: Next.js 14
- **Styling**: Tailwind CSS
`;

      const file2Content = `---
title: Backend Rules
---

## Tech Stack
- **Database**: PostgreSQL
- **ORM**: Prisma
`;

      const file1 = new File([file1Content], 'frontend.mdc', { type: 'text/plain' });
      const file2 = new File([file2Content], 'backend.mdc', { type: 'text/plain' });

      let importResult;
      await act(async () => {
        importResult = await result.current.importFromFiles([file1, file2]);
      });

      const ts = importResult!.projectContext.techStack;
      expect(ts.framework).toBe('Next.js 14');
      expect(ts.styling).toBe('Tailwind CSS');
      expect(ts.database).toBe('PostgreSQL');
      expect(ts.orm).toBe('Prisma');
    });

    it('should deduplicate conventions', async () => {
      const { result } = renderHook(() => useCursorRulesImport());

      const content = `## Code Style
- Use \`cn()\` utility for Tailwind
- Use \`cn()\` utility for Tailwind
`;

      const file1 = new File([content], 'file1.mdc', { type: 'text/plain' });
      const file2 = new File([content], 'file2.mdc', { type: 'text/plain' });

      let importResult;
      await act(async () => {
        importResult = await result.current.importFromFiles([file1, file2]);
      });

      // Should not have duplicates
      const uniqueRules = new Set(importResult!.projectContext.conventions.map((c) => c.rule));
      expect(uniqueRules.size).toBe(importResult!.projectContext.conventions.length);
    });
  });
});

describe('formatTechStack', () => {
  it('should format tech stack as string', () => {
    const techStack = extractTechStack(sampleMDCContent);
    const formatted = formatTechStack(techStack);

    expect(formatted).toContain('Framework: Next.js 14');
    expect(formatted).toContain('Language: TypeScript');
    expect(formatted).toContain('Styling: Tailwind CSS');
  });

  it('should handle empty tech stack', () => {
    const formatted = formatTechStack({ items: [] });
    expect(formatted).toBe('');
  });
});

describe('validateMDCContent', () => {
  it('should validate valid content', () => {
    const { valid, errors } = validateMDCContent(sampleMDCContent);

    expect(valid).toBe(true);
    expect(errors).toEqual([]);
  });

  it('should reject empty content', () => {
    const { valid, errors } = validateMDCContent('');

    expect(valid).toBe(false);
    expect(errors).toContain('Content is empty');
  });

  it('should detect unclosed frontmatter', () => {
    const content = `---
title: Test
# Missing closing ---

Body content`;

    const { valid, errors } = validateMDCContent(content);

    expect(valid).toBe(false);
    expect(errors.some((e) => e.includes('Frontmatter'))).toBe(true);
  });

  it('should accept content without frontmatter', () => {
    const content = '# Just markdown without frontmatter';
    const { valid, errors } = validateMDCContent(content);

    expect(valid).toBe(true);
    expect(errors).toEqual([]);
  });
});

describe('cross-platform compatibility', () => {
  it('should handle Windows line endings (CRLF)', () => {
    const content = '---\r\ntitle: Test\r\n---\r\n\r\nBody content';
    const { frontmatter, body } = parseFrontmatter(content);

    expect(frontmatter.title).toBe('Test');
    expect(body).toContain('Body content');
  });

  it('should handle mixed line endings', () => {
    const content = '---\r\ntitle: Test\n---\n\r\nBody content';
    const { frontmatter, body } = parseFrontmatter(content);

    expect(frontmatter.title).toBe('Test');
    expect(body).toContain('Body content');
  });

  it('should handle old Mac line endings (CR)', () => {
    const content = '---\rtitle: Test\r---\r\rBody content';
    const { frontmatter, body } = parseFrontmatter(content);

    expect(frontmatter.title).toBe('Test');
    expect(body).toContain('Body content');
  });
});

describe('content size validation', () => {
  it('should reject oversized files in importFromFiles', async () => {
    const { result } = renderHook(() => useCursorRulesImport());

    // Create a mock file that reports a large size
    const largeFile = new File(['small content'], 'large.mdc', { type: 'text/plain' });
    Object.defineProperty(largeFile, 'size', { value: 15 * 1024 * 1024 }); // 15MB

    let importResult;
    await act(async () => {
      importResult = await result.current.importFromFiles([largeFile]);
    });

    expect(importResult!.errors.length).toBe(1);
    expect(importResult!.errors[0].error).toContain('exceeds maximum size');
  });
});
